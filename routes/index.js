var express = require('express');var bcrypt = require('bcrypt');var router = express.Router();// var { DriverInfo } =  require('./utils/classes');// var auth = require('../auth')// router.all('*', auth)router.get('/order/approve/:order_id', (req, res, next)=>{ var postData = req.body var data = { }	Order.findById(req.params.order_id, {		include:[{			model:Order_detail,			// attributes: ["item"],			include:[{				model:Product,				attributes: ["item", "prep_time", "unit", "description", "image"]			}]		}, 		{			model: User_location,			as:"delivery",			attributes: ["lat", "lng", "address", "location"]		}, 		{			model: User,			as:"customer",			attributes: ["fullName", "address", "phone"]		},		{			model: User,			as:"vendor",			attributes: ["lat", "lng", "fullName","business_name","business_name_arb", "prep_time", "address", "location","phone", "image"],			include:[{				model:User_rush_time,			}]		}]	})	.then(order=>{		// console.log(JSON.stringify(order.get({plain:true})))		data.order  = order.get({plain:true})		if(!data.order.status)	order.status = 1 			//	let 20 min min delivery time 			order.estimated_time =  order.vendor.prep_time+20			if(rushtime = data.order.vendor.user_rush_time){			var a = moment(rushtime.from, "hh:mm") ;			var b = moment(rushtime.to, "hh:mm") ;			var x = 	moment(new Date().toLocaleTimeString(), "hh:mm")			if(x.isBefore(b) && a.isBefore(x))				order.estimated_time+= rushtime.duration			}			return order.save()	})	.then(order=>{		//	query to get near by users from this order {geo}		return sequelize.query(`			SELECT d1.id as driver_id, d1.name, d1.device_token,d1.device_type,			(3959*acos(cos(radians(v1.lat))*cos(radians(d1.lat))*cos(radians(d1.lng) - radians(v1.lng)) + sin(radians(v1.lat))*sin(radians(d1.lat)))) as r1,			(3959*acos(cos(radians(ul.lat))*cos(radians(d1.lat))*cos(radians(d1.lng) - radians(ul.lng)) + sin(radians(ul.lat))*sin(radians(d1.lat)))) as r2, SUM(CASE WHEN o2.status != 8 THEN 1 ELSE 0 END) as total_order_per_driver			FROM orders as o1 			cross JOIN drivers as d1 			left join orders as o2 on o2.driver_id = d1.id 			left join user_locations as ul on ul.id = o1.delivery_location 			inner JOIN users as v1 ON(v1.id = o1.vendor_id) 			WHERE o1.id= ?  and  d1.online>d1.offline GROUP BY d1.id  HAVING r1+r2 <=10 and  total_order_per_driver < 4`,			//			{ replacements: 				[req.params.order_id], type: sequelize.QueryTypes.SELECT 		})	})	.then(drivers=>{		const { users } = require('../socket/shared');		console.log(`drivers.length`, drivers)		console.log(`users.length`, Object.keys(users))		drivers.forEach(v=>{			console.log(v.driver_id)			var client = users[v.driver_id]			if(client)				client.emit("newOrder", data.order)			else			// if(v.driver_id==13)				PX.sendPush(v, "New order", {key:"NewOrder", order_id: req.params.order_id})		})		return res.status(200).json({			replyCode: "success",			data:data.order,			replyMsg: "order approved successfully"		 });	})	.catch(err=>{	 return next(err);	}); });router.post('/uploadmedia', (req, res, next)=>{	// console.log(req.files);	PX.uploadFile(req.files.image, 'users', false)	.then(filename=>{		res.status(200).json({			replyCode: "success",			data: { image_name: filename, viewPath : aws_path +filename },			replyMsg: "upload successfully"		});	})	.catch(err=>{		return next(err)	})})router.post('/login', (req, res, next)=>{	var postData = req.body;	var data = { }	Driver.findOne({		where:{				$or:{				phone : postData.phone,				email: postData.phone			} 		}	 })	.then(user=>{		if(!user)			return next(new Error(DM.user_not_found))				user.device_token = postData.device_token		user.device_type = postData.device_type		user.access_token =	PX.crypto(user.id.toString()+ new Date().getTime(), 'encrypt')		data.user =	user.get({plain:true})		if(sha1(process.env.secret + postData.password)!= data.user.password)			return next(new Error(DM.incorrect_email_password))		if(!data.user.verified)			return	new Promise((resolve, reject) => {				reject(new Error(DM.account_not_approved))			});			data.user.ssid = PX.crypto(data.user.id, 'encrypt')			res.status(200).json({				replyCode: "success",				data: data.user,				replyMsg: "Login successfully"			});		return  user.save();	})	.then(done=>{		return this;	})			.catch(err=> {				return next(err);	});});  	router.post('/resendOtp', (req, res, next)=>{	var postData = req.body;	var data = { }	var otp =  		randomString.generate({			length: 4,			charset: 'numeric'		});	 Driver.findOne({		where:{			$or:{				phone : postData.phone.slice(-10),				email: postData.phone			} 		}	 })	.then(user=>{		if(!user)			return new Promise((resolve, reject) => {					reject(new Error(DM.user_not_found))			});		data.user= user		data.user.otp = otp		data.user.device_type = postData.device_type		data.user.device_token = postData.device_token		return	Email_template.findOne({				where:{					email_type:'confirmation_code'				}			})		})		.then(template=>{				template = template.get({plain:true})			var msg = template.message			msg = msg.replace("\[name\]", data.user.name)			msg = msg.replace("\[otp\]", otp)			msg = msg.replace("\[site_title\]", process.env.sitename)			template.message  = msg			console.log(data.user.phone);			Promise.all([				PX.sendMail(template, data.user),			 	PX.sendMsg("+40"+data.user.phone, "Fudoo verification code is "+otp)])		})	.then(done=>{		console.log(done)		return  data.user.save()	})	.then(user=>{		user =	user.toObject()		user.ssid = PX.crypto(user.id, 'encrypt')		res.status(200).json({			replyCode: "success",			data: user,			replyMsg: "Otp sent successfully"		});	})	.catch(err=> {		return next(err);	});})router.post('/signup', (req, res, next)=>{	var postData = req.body;	var data = { }	postData.password =  sha1(process.env.secret + postData.password)	postData.otp =  			randomString.generate({				length: 4,				charset: 'numeric'			});	var otp = postData.otp	 Driver.findOne({		where:{			$or:{				email : postData.email,				phone : postData.phone			}		}	 })	.then(user=>{		if(!user)			return Driver.create(postData)				var user = user.get({plain:true});		console.log(user)		return new Promise((resolve, reject) => {			if(user.email == postData.email)				reject(new Error(DM.email_already_registered))			else 				reject(new Error(DM.mobile_already_registered))		});	})	.then(user=>{		data.user  = user 		return Promise.all([			Email_template.findOne({				where:{					email_type:'registration'				}			}),		Email_template.findOne({			where:{				email_type:'confirmation_code'			}		})		])	})	.then(templates=>{			var template  = templates[0]		var template1  = templates[1]		var msg = template.message		msg = msg.replace("\[username\]", postData.name)		msg = msg.replace("\[site_title\]", process.env.sitename)		template.message  = msg			template1 = template1.get({plain:true})		var msg = template1.message		msg = msg.replace("\[name\]", data.user.name)		msg = msg.replace("\[otp\]", otp)		msg = msg.replace("\[sitename\]", process.env.sitename)		template1.message  = msg		console.log(data.user.phone);		return Promise.all([				PX.sendMail(template1, data.user),			 	PX.sendMsg("+40"+data.user.phone, "Fudoo verification code is "+otp),				PX.sendMail(template, postData)				])	})	.then(done=>{		user =	data.user.toObject()		user.ssid = PX.crypto(user.id, 'encrypt')		res.status(200).json({			replyCode: "success",			data: user,			replyMsg: "Signup successfully"		});	})	.catch(err=> {		return next(err);	});});router.get('/static/:slug', function(req, res, next) {	Content.findOne({		where:{			slug:req.params.slug		}	})	.then(content=>{		res.render('static/basic', { content: content.body })	})});router.post('/verfiyOtp', (req, res, next)=>{	var postData = req.body;	 Driver.findOne({		where:{			$or:[				{					phone:postData.phone.slice(-10),				},				{					email: postData.phone				}			]		}	 })	.then(user=>{		if(!user)			return new Promise((resolve, reject) => {				reject(new Error(DM.user_not_found))			});		console.log(`user.otp`, user.otp);		if(postData.otp!=user.otp)			return new Promise((resolve, reject) => {				reject(new Error(DM.wrong_otp))			});		// user.verified = 1		return	user.save()	})	.then(user=>{		user =	user.toObject()		user.ssid = PX.crypto(user.id, 'encrypt')		if(!user.verified)			res.status(400).json({				replyCode: "error",				replyMsg: DM.account_not_approved			});		else			res.status(200).json({				replyCode: "success",				data: user,				replyMsg: "otp verified successfully"			});	})	.catch(err=> {		return next(err);	});});module.exports = router; 